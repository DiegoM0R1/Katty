<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Para Katty de tu Cholasho❤️ - Versión 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            color: white;
            background: #000;
        }
        
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        .centered-card {
            display: none;
            justify-content: center;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        .card-content {
            background: linear-gradient(135deg, #ff7f50, #ff4757);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            color: white;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5),
                        0 0 100px rgba(255, 79, 87, 0.6),
                        inset 0 0 20px rgba(255, 255, 255, 0.2);
            width: 80%;
            max-width: 800px;
            height: auto;
            max-height: 90%;
            overflow-y: auto;
            animation: fadeIn 1s ease-out, float 6s ease-in-out infinite;
            transform-style: preserve-3d;
            perspective: 1000px;
        }

        .card-content p {
            font-size: 18px;
            line-height: 1.8;
            margin: 0;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
            transform: translateZ(20px);
        }

        .close {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 30px;
            color: white;
            cursor: pointer;
            transition: all 0.4s;
            z-index: 10;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .close:hover {
            transform: scale(1.3) rotate(90deg);
            text-shadow: 0 0 20px rgba(255, 255, 255, 1);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.8) rotateX(-10deg);
            }
            to {
                opacity: 1;
                transform: scale(1) rotateX(0);
            }
        }
        
        @keyframes float {
            0%, 100% {
                transform: translateY(0) rotateX(0deg);
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5),
                            0 0 100px rgba(255, 79, 87, 0.6);
            }
            50% {
                transform: translateY(-15px) rotateX(3deg);
                box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3),
                            0 0 120px rgba(255, 79, 87, 0.8);
            }
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
        }

        .modal-content {
            position: relative;
            margin: 15% auto;
            padding: 30px;
            width: 90%;
            max-width: 500px;
            background: linear-gradient(135deg, #ff7f50, #ff4757);
            border-radius: 20px;
            text-align: center;
            color: white;
            box-shadow: 0 15px 50px rgba(0,0,0,0.5),
                        0 0 100px rgba(255, 100, 100, 0.4);
            animation: modalAppear 0.8s cubic-bezier(0.17, 0.89, 0.32, 1.25);
            transform-style: preserve-3d;
        }
        
        .modal-content::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, 
                rgba(255, 255, 255, 0.1), 
                rgba(255, 255, 255, 0.3), 
                rgba(255, 255, 255, 0.1), 
                rgba(255, 255, 255, 0.3));
            z-index: -1;
            border-radius: 22px;
            animation: borderGlow 3s linear infinite;
        }

        @keyframes borderGlow {
            0%, 100% {
                opacity: 0.8;
            }
            50% {
                opacity: 0.3;
            }
        }

        @keyframes modalAppear {
            from {
                transform: scale(0.5) rotateX(-30deg);
                opacity: 0;
            }
            to {
                transform: scale(1) rotateX(0);
                opacity: 1;
            }
        }

        .modal-content p {
            font-size: 24px;
            margin: 0;
            text-shadow: 2px 2px 6px rgba(0,0,0,0.4);
            transform: translateZ(30px);
        }
        
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #ff4757, #ff7f50);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 1s ease-out;
        }
        
        .loading-text {
            font-size: 24px;
            margin-top: 20px;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            animation: pulse 1.5s infinite;
        }
        
        .loading-heart {
            font-size: 50px;
            animation: heartbeat 1.2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes heartbeat {
            0% { transform: scale(1); }
            15% { transform: scale(1.3); }
            30% { transform: scale(1); }
            45% { transform: scale(1.3); }
            60% { transform: scale(1); }
            100% { transform: scale(1); }
        }
        
        .controls-hint {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.6);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 14px;
            opacity: 0.7;
            z-index: 100;
            transition: opacity 0.3s;
        }
        
        .controls-hint:hover {
            opacity: 1;
        }
        
        /* Estilos para los controles de la pantalla digital */
        .screen-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .control-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255, 79, 87, 0.8);
            border: none;
            border-radius: 12px;
            padding: 10px;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }
        
        .control-btn:hover {
            background: rgba(255, 127, 80, 0.9);
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .btn-icon {
            font-size: 24px;
            margin-bottom: 5px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .btn-text {
            font-size: 12px;
            font-weight: bold;
        }
        
        /* Indicador de música activa */
        .music-active .btn-icon {
            animation: pulse 1s infinite alternate;
        }
        
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.2); }
        }
        /* Estilos para controles móviles */
    .mobile-controls {
        display: none; /* Oculto por defecto, se muestra en dispositivos móviles */
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 30vh;
        z-index: 900;
        touch-action: none;
    }
    
    .joystick-container {
        position: absolute;
        bottom: 20px;
        left: 20px;
        width: 120px;
        height: 120px;
    }
    
    .joystick-base {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
        border: 2px solid rgba(255, 255, 255, 0.3);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }
    
    .joystick-thumb {
        width: 50%;
        height: 50%;
        background: rgba(255, 79, 87, 0.8);
        border-radius: 50%;
        position: relative;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
        transition: transform 0.1s ease;
    }
    
    .mobile-buttons {
        position: absolute;
        bottom: 40px;
        right: 20px;
        display: flex;
        gap: 15px;
    }
    
    .mobile-btn {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: rgba(255, 79, 87, 0.8);
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 24px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(5px);
    }
    
    .mobile-btn:active {
        transform: scale(0.9);
    }
    
    .mobile-btn-icon {
        font-size: 30px;
        text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }
    
    /* Texto de ayuda para móviles */
    .mobile-controls-hint {
        position: fixed;
        top: 20px;
        left: 0;
        width: 100%;
        text-align: center;
        background: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 10px;
        font-size: 14px;
        z-index: 100;
        display: none;
        backdrop-filter: blur(5px);
    }
    
    /* Responsividad para móviles */
    @media (max-width: 768px) {
        .controls-hint {
            display: none; /* Ocultar controles de PC */
        }
        
        .screen-controls {
            display: none; /* Ocultar controles de PC */
        }
        
        .mobile-controls {
            display: block; /* Mostrar controles móviles */
        }
        
        .mobile-controls-hint {
            display: block; /* Mostrar ayuda para móviles */
        }
    }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-heart">❤️</div>
        <div class="loading-text">Cargando nuestro mundo...</div>
    </div>
    
    <div class="controls-hint">Usa el ratón para mirar alrededor y las teclas WASD para moverte</div>
    
    <!-- Reemplazamos la tarjeta centrada con la pantalla digital 3D que se manejará en Three.js -->
    <div id="screenControls" class="screen-controls">
        <button id="toggleScreen" class="control-btn">
            <span class="btn-icon">💌</span>
            <span class="btn-text">Mostrar Mensaje</span>
        </button>
        <button id="toggleMusic" class="control-btn">
            <span class="btn-icon">🎵</span>
            <span class="btn-text">Música</span>
        </button>
    </div>

    <div id="myModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <p>Amooooooooor e construido este mundito para ti<3</p>
        </div>
    </div>

    <audio id="audioPlayer" src="Daft Punk - Touch (Choral Version from Epilogue - Extended).mp3" preload="auto" style="display:none"></audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.min.js"></script>
    <script>
        // Variables principales
        let scene, camera, renderer, composer;
        let sun, palmGroup, flowerField, cat, hearts = [];
        let clock = new THREE.Clock();
        const loader = new THREE.TextureLoader();
        
        // Manejo de audio con un efecto de fade in
        function setupAudio() {
            const audioElement = document.getElementById('audioPlayer');
            // Usamos la ruta original del archivo
            // Ya está definida en el elemento audio como "Daft Punk - Touch (Choral Version from Epilogue - Extended).mp3"
            audioElement.loop = true;
            audioElement.volume = 0;
            
            // Hacemos un fade in del volumen
            let vol = 0;
            const intervalId = setInterval(() => {
                if (vol < 0.5) {
                    vol += 0.01;
                    audioElement.volume = vol;
                } else {
                    clearInterval(intervalId);
                }
            }, 100);
            
            // Marcamos que la música está reproduciéndose
            isMusicPlaying = true;
            const musicBtn = document.getElementById('toggleMusic');
            if (musicBtn) {
                musicBtn.classList.add('music-active');
                musicBtn.querySelector('.btn-text').textContent = 'Pausar';
                musicBtn.querySelector('.btn-icon').textContent = '♫';
            }
        }
        
        // Inicializar la escena
        function init() {
            // Crear escena
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0xff7e57, 0.02);
            
            // Configurar cámara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 20);
            camera.lookAt(0, 5, 0);
            
            // Configurar renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);
            
            // Añadir luz ambiental para iluminación general
            const ambientLight = new THREE.AmbientLight(0xffd4b3, 0.5);
            scene.add(ambientLight);
            
            // Crear elementos de la escena
            createSkybox();
            createSun();
            createGround();
            createPalms();
            createFlowers();
            createCat();
            createParticles();
            createDigitalScreen();
            
            // Configurar eventos y controles
            setupControls();
            setupScreenControls();
            window.addEventListener('resize', onWindowResize);
            
            // Ocultar la pantalla de carga después de inicializar todo
            setTimeout(() => {
                document.getElementById('loadingScreen').style.opacity = 0;
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    document.getElementById('myModal').style.display = 'block';
                }, 1000);
            }, 1500);
            
            // Iniciar la animación
            animate();
        }
        
        function setupScreenControls() {
            // Configurar los controles de la pantalla digital
            document.getElementById('toggleScreen').addEventListener('click', toggleScreen);
            document.getElementById('toggleMusic').addEventListener('click', toggleMusic);
            
            // Configurar controles de scroll para la pantalla
            document.addEventListener('keydown', (event) => {
                if (isScreenVisible) {
                    if (event.key === 'ArrowUp') {
                        // Scroll hacia arriba en el texto
                        window.screenTextOffset = Math.max(0, window.screenTextOffset - 1);
                    } else if (event.key === 'ArrowDown') {
                        // Scroll hacia abajo en el texto
                        window.screenTextOffset = Math.min(13, window.screenTextOffset + 1);
                    }
                }
            });
        }
        
        // Crear el skybox (cielo)
        function createSkybox() {
            // Creamos un gradiente de cielo con geometría
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            
            // Material para el cielo con gradiente de atardecer
            const uniforms = {
                topColor: { value: new THREE.Color(0xff0026) },
                bottomColor: { value: new THREE.Color(0x004ac9) },
                offset: { value: 50 },
                exponent: { value: 0.6 }
            };
            
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
            
            // Añadir estrellas al cielo
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.7,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            const starsVertices = [];
            for (let i = 0; i < 1000; i++) {
                const x = THREE.MathUtils.randFloatSpread(600);
                const y = THREE.MathUtils.randFloat(50, 250); // Estrellas solo en la parte superior
                const z = THREE.MathUtils.randFloatSpread(600);
                starsVertices.push(x, y, z);
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);
        }
        
        // Crear el sol
        function createSun() {
            const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xff5500,
                transparent: true,
                opacity: 0.9
            });
            
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(0, 60, -150);
            scene.add(sun);
            
            // Añadir resplandor al sol
            const sunLightGeometry = new THREE.SphereGeometry(15, 32, 32);
            const sunLightMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.5
            });
            
            const sunGlow = new THREE.Mesh(sunLightGeometry, sunLightMaterial);
            sun.add(sunGlow);
            
            // Luz direccional para simular la luz del sol
            const sunLight = new THREE.DirectionalLight(0xfffaf0, 1);
            sunLight.position.set(0, 100, -150);
            sunLight.castShadow = true;
            sunLight.shadow.camera.far = 300;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            sunLight.shadow.mapSize.width = 1024;
            sunLight.shadow.mapSize.height = 1024;
            scene.add(sunLight);
        }
        
        // Crear el suelo
        function createGround() {
            // Arena
            const sandGeometry = new THREE.PlaneGeometry(1000, 1000);
            const sandMaterial = new THREE.MeshStandardMaterial({
                color: 0xd4b94b,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const sand = new THREE.Mesh(sandGeometry, sandMaterial);
            sand.rotation.x = -Math.PI / 2;
            sand.position.y = -1;
            sand.receiveShadow = true;
            scene.add(sand);
            
            // Agua
            const waterGeometry = new THREE.PlaneGeometry(1000, 800);
            const waterMaterial = new THREE.MeshStandardMaterial({
                color: 0x0088ff,
                roughness: 0.1,
                metalness: 0.6,
                transparent: true,
                opacity: 0.8
            });
            
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = -0.5;
            water.position.z = -300;
            scene.add(water);
        }
        
        // Crear palmeras
        function createPalms() {
            palmGroup = new THREE.Group();
            scene.add(palmGroup);
            
            // Función para crear una sola palmera
            function createPalm(x, z, scaleVal = 1, rotY = 0) {
                const palm = new THREE.Group();
                
                // Tronco
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 15, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.9,
                    metalness: 0.1
                });
                
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.castShadow = true;
                trunk.position.y = 7.5;
                
                // Inclinación aleatoria del tronco
                trunk.rotation.x = THREE.MathUtils.randFloatSpread(0.1);
                trunk.rotation.z = THREE.MathUtils.randFloatSpread(0.1);
                
                palm.add(trunk);
                
                // Hojas
                const leafShape = new THREE.Shape();
                leafShape.moveTo(0, 0);
                leafShape.bezierCurveTo(2, 1, 8, 1.5, 10, 0);
                leafShape.bezierCurveTo(8, -1.5, 2, -1, 0, 0);
                
                const extrudeSettings = {
                    depth: 0.1,
                    bevelEnabled: true,
                    bevelThickness: 0.1,
                    bevelSize: 0.1,
                    bevelSegments: 3
                };
                
                const leafGeometry = new THREE.ExtrudeGeometry(leafShape, extrudeSettings);
                const leafMaterial = new THREE.MeshStandardMaterial({
                    color: 0x00aa00,
                    roughness: 0.8,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                });
                
                // Crear varias hojas y posicionarlas
                for (let i = 0; i < 7; i++) {
                    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                    leaf.castShadow = true;
                    leaf.rotation.z = (i * Math.PI / 3.5);
                    leaf.rotation.y = (i * Math.PI / 7);
                    leaf.position.y = 15;
                    leaf.scale.set(1, 1 + Math.random() * 0.5, 1);
                    palm.add(leaf);
                }
                
                // Posicionar la palmera completa
                palm.position.set(x, 0, z);
                palm.rotation.y = rotY;
                palm.scale.set(scaleVal, scaleVal, scaleVal);
                
                return palm;
            }
            
            // Distribuir varias palmeras
            const palmPositions = [
                { x: -25, z: 0, scale: 1.2, rotY: Math.PI/4 },
                { x: -18, z: 8, scale: 0.9, rotY: Math.PI/3 },
                { x: 25, z: 5, scale: 1.1, rotY: -Math.PI/5 },
                { x: 20, z: -8, scale: 0.8, rotY: -Math.PI/6 },
                { x: -12, z: -15, scale: 1, rotY: Math.PI/8 },
                { x: 15, z: -18, scale: 1.3, rotY: -Math.PI/9 },
                { x: -30, z: -25, scale: 1.5, rotY: Math.PI/7 },
                { x: 30, z: -30, scale: 1.4, rotY: -Math.PI/8 }
            ];
            
            palmPositions.forEach(pos => {
                const palm = createPalm(pos.x, pos.z, pos.scale, pos.rotY);
                palmGroup.add(palm);
            });
        }
        
        // Crear flores
        function createFlowers() {
            flowerField = new THREE.Group();
            scene.add(flowerField);
            
            // Función para crear una flor
            function createFlower(x, z, scale = 1, color = 0xffc400) {
                const flower = new THREE.Group();
                
                // Tallo
                const stemGeometry = new THREE.CylinderGeometry(0.1, 0.15, 3, 8);
                const stemMaterial = new THREE.MeshStandardMaterial({
                    color: 0x2ecc71,
                    roughness: 0.8
                });
                
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                stem.castShadow = true;
                stem.position.y = 1.5;
                flower.add(stem);
                
                // Centro de la flor
                const centerGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const centerMaterial = new THREE.MeshStandardMaterial({
                    color: 0x23200a,
                    roughness: 0.9
                });
                
                const center = new THREE.Mesh(centerGeometry, centerMaterial);
                center.castShadow = true;
                center.position.y = 3.2;
                flower.add(center);
                
                // Pétalos
                const petalGeometry = new THREE.ConeGeometry(0.8, 1.5, 4);
                const petalMaterial = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.6,
                    metalness: 0.1
                });
                
                // Crear pétalos alrededor del centro
                for (let i = 0; i < 8; i++) {
                    const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                    petal.castShadow = true;
                    
                    // Posicionar alrededor del centro
                    const angle = (i / 8) * Math.PI * 2;
                    petal.position.set(
                        Math.cos(angle) * 0.6,
                        3.2,
                        Math.sin(angle) * 0.6
                    );
                    
                    // Apuntar hacia afuera
                    petal.lookAt(
                        Math.cos(angle) * 10,
                        3.2,
                        Math.sin(angle) * 10
                    );
                    
                    // Rotar para que el cono apunte hacia afuera
                    petal.rotateX(Math.PI / 2);
                    
                    flower.add(petal);
                }
                
                // Posicionar la flor completa
                flower.position.set(x, 0, z);
                flower.scale.set(scale, scale, scale);
                
                return flower;
            }
            
            // Distribuir múltiples flores
            const flowerColors = [0xffc400, 0xff9500, 0xff5f00, 0xffcc00, 0xff8800];
            
            for (let i = 0; i < 80; i++) {
                const x = THREE.MathUtils.randFloatSpread(60);
                const z = THREE.MathUtils.randFloatSpread(60);
                const scale = 0.3 + Math.random() * 0.3;
                const colorIndex = Math.floor(Math.random() * flowerColors.length);
                
                // Evitar colocar flores muy cerca de las palmeras
                let tooClose = false;
                palmGroup.children.forEach(palm => {
                    const dx = palm.position.x - x;
                    const dz = palm.position.z - z;
                    const distSq = dx * dx + dz * dz;
                    if (distSq < 25) { // 5 al cuadrado
                        tooClose = true;
                    }
                });
                
                if (!tooClose) {
                    const flower = createFlower(x, z, scale, flowerColors[colorIndex]);
                    flowerField.add(flower);
                }
            }
        }
        
        // Crear el gato
        // Pantalla digital 3D
        let digitalScreen;
        let isScreenVisible = false;
        let isMusicPlaying = false;
        
        function createDigitalScreen() {
            // Grupo principal para la pantalla
            digitalScreen = new THREE.Group();
            
            // Crear el marco de la pantalla (más grande)
            const frameGeometry = new THREE.BoxGeometry(30, 20, 0.5);
            const frameMaterial = new THREE.MeshStandardMaterial({
                color: 0xff4757,
                roughness: 0.2,
                metalness: 0.8,
                emissive: 0xff4757,
                emissiveIntensity: 0.2
            });
            
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.castShadow = true;
            frame.receiveShadow = true;
            digitalScreen.add(frame);
            
            // Crear la pantalla en sí (más grande)
            const screenGeometry = new THREE.PlaneGeometry(29, 19);
            
            // Crear un canvas para la textura de la pantalla
            const canvas = document.createElement('canvas');
            canvas.width = 1400;
            canvas.height = 900;
            const context = canvas.getContext('2d');
            
            // Rellenar el fondo
            context.fillStyle = 'rgba(0, 0, 0, 0.8)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Añadir un borde brillante
            context.strokeStyle = 'rgba(255, 127, 80, 0.8)';
            context.lineWidth = 10;
            context.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);
            
            // Añadir un gradiente de fondo
            const gradient = context.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, 'rgba(255, 79, 87, 0.2)');
            gradient.addColorStop(0.5, 'rgba(255, 127, 80, 0.1)');
            gradient.addColorStop(1, 'rgba(255, 204, 0, 0.2)');
            context.fillStyle = gradient;
            context.fillRect(10, 10, canvas.width - 20, canvas.height - 20);
            
            // Configurar el estilo del texto
            context.font = 'bold 36px Arial';
            context.textAlign = 'center';
            context.fillStyle = 'white';
            context.shadowColor = 'rgba(255, 127, 80, 0.8)';
            context.shadowBlur = 15;
            
            // Escribir el texto del mensaje
            const text = [
                "Mi amor,",
                "",
                "Amor, ya vamos más de dos meses, y cada día que pasa me doy cuenta ",
                "de algo: quiero que estés en mi vida, no solo ahorita, sino siempre.",
                "No me importa la distancia, no me importa lo que venga, yo estoy aquí, ",
                "contigo, y siempre vas a estar en mis planes. Porque tú no eres un  ",
                "agregado, tú eres el centro de todo.",
                "",
                "Estoy terminando mi carrera, y aunque estos meses hayamos tenido pequeños ",
                "problemas, siempre lo hemos solucionado, lo que más me motiva es pensar en ",
                "el momento en que ya podamos estar juntos, sin estar contando los días ni las horas.",
                "Cada vez que despierto y veo tu mensaje, siento que el día va a ser mejor.",
                "Cada vez que me dices que me quieres, siento que el mundo es un lugar mejor.",
                "Cada viaje que hago para verte, yo se que no son muchos jeje, siempre voy",
                "emocionado, se que aprendere algo nuevo sobre el amor contigo.",
                "",
                "Me gusta como me tratas, como me miras, como te preocupas por mi,",
                "podria tener el plan mas aburrido del mundo, pero si estoy contigo,",
                "siento que estoy en el mejor lugar del mundo.",
                "Eres mi chikistrikis, mi amorcito, mi niña pechocha, mi enojoncita, jeje bromita",
                "no te enojas tu jeje, te quiero mucho, los dias pasan volando, creo que",
                "el Diosito está yendo a nuestro favor, hay muchas cosas que quiero hacer",
                "juntos, la paciencia no es mi mejor virtud, y por ti espero lo que sea necesario.",
                "",
                "No olvides que estás en mi corazoncito, se que me faltan detalles contigo, ",
                "de momento no tengo mucho dinero, y mediante esta detalle digital intangible",
                "te estoy expresando lo mis mas sinceros sentimeintos, espero te guste.",
                "De tu cholashooooo.",
                "",
            ];
            
            // Crear una textura animada para el texto (solo crearemos la primera parte)
            window.updateScreenText = function(offset = 0) {
                // Limpiar el canvas
                context.fillStyle = 'rgba(0, 0, 0, 0.8)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // Añadir el borde
                context.strokeStyle = 'rgba(255, 127, 80, 0.8)';
                context.lineWidth = 10;
                context.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);
                
                // Añadir el gradiente
                context.fillStyle = gradient;
                context.fillRect(10, 10, canvas.width - 20, canvas.height - 20);
                
                // Configurar el estilo del texto
                context.font = 'bold 32px Arial';
                context.textAlign = 'center';
                context.fillStyle = 'white';
                context.shadowColor = 'rgba(255, 127, 80, 0.8)';
                context.shadowBlur = 15;
                
                // Dibujar las líneas visibles actualmente
                const visibleLines = 14; // Número de líneas visibles a la vez
                const startLine = Math.floor(offset);
                
                for (let i = 0; i < visibleLines && i + startLine < text.length; i++) {
                    context.fillText(
                        text[i + startLine], 
                        canvas.width / 2, 
                        100 + i * 50
                    );
                }
                
                // Añadir indicador de desplazamiento y controles
                context.fillStyle = 'rgba(255, 255, 255, 0.9)';
                context.font = 'bold 24px Arial';
                context.fillText('↑↓ Desplazar • ❤️ Tu Cholasho Diego', canvas.width / 2, canvas.height - 40);
                
                // Añadir indicador de música
                if (isMusicPlaying) {
                    context.fillStyle = '#ff4757';
                    context.font = 'bold 28px Arial';
                    context.fillText('♫ Música: Daft Punk - Touch ♫', canvas.width / 2, 50);
                }
                
                // Actualizar la textura
                screenTexture.needsUpdate = true;
            };
            
            // Crear la textura a partir del canvas
            const screenTexture = new THREE.CanvasTexture(canvas);
            
            const screenMaterial = new THREE.MeshBasicMaterial({
                map: screenTexture,
                side: THREE.FrontSide
            });
            
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.z = 0.26;
            digitalScreen.add(screen);
            
            // Añadir soporte para la pantalla (más grande y adaptado para estar en el suelo)
            const standGeometry = new THREE.BoxGeometry(3, 0.5, 3);
            const standMaterial = new THREE.MeshStandardMaterial({
                color: 0xff4757,
                roughness: 0.3,
                metalness: 0.7
            });
            
            const stand = new THREE.Mesh(standGeometry, standMaterial);
            stand.position.y = -10.25;
            stand.position.z = 0;
            digitalScreen.add(stand);
            
            // Posicionar y orientar toda la pantalla - ahora está en el suelo
            digitalScreen.position.set(0, 10, -20); // Posición central, en el suelo, algo alejada
            digitalScreen.rotation.x = Math.PI * 0.1; // Ligera inclinación hacia arriba para mejor visibilidad
            digitalScreen.visible = false;
            
            scene.add(digitalScreen);
            
            // Inicializar el texto
            window.updateScreenText(0);
            
            // Variables para el scroll del texto
            window.screenTextOffset = 0;
            
            // Llamar a la actualización periódicamente para animar
            setInterval(() => {
                if (digitalScreen.visible) {
                    window.updateScreenText(window.screenTextOffset);
                }
            }, 100);
        }
        
        function toggleScreen() {
            isScreenVisible = !isScreenVisible;
            digitalScreen.visible = isScreenVisible;
            
            // Animación de aparición/desaparición con TWEEN
            if (isScreenVisible) {
                digitalScreen.scale.set(0.1, 0.1, 0.1);
                new TWEEN.Tween(digitalScreen.scale)
                    .to({ x: 0.5, y: 0.5, z: 0.5 }, 1000)
                    .easing(TWEEN.Easing.Elastic.Out)
                    .start();
                
                new TWEEN.Tween(digitalScreen.rotation)
                    .to({ z: Math.PI * 2 }, 1000)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                
                document.getElementById('toggleScreen').querySelector('.btn-text').textContent = 'Ocultar Mensaje';
            } else {
                new TWEEN.Tween(digitalScreen.scale)
                    .to({ x: 0.1, y: 0.1, z: 0.1 }, 500)
                    .easing(TWEEN.Easing.Back.In)
                    .onComplete(() => {
                        digitalScreen.visible = false;
                        digitalScreen.scale.set(0.5, 0.5, 0.5);
                        digitalScreen.rotation.z = 0;
                    })
                    .start();
                
                document.getElementById('toggleScreen').querySelector('.btn-text').textContent = 'Mostrar Mensaje';
            }
        }
        
        function toggleMusic() {
            const audioPlayer = document.getElementById('audioPlayer');
            const musicBtn = document.getElementById('toggleMusic');
            
            if (isMusicPlaying) {
                // Pausar música con fade out
                let vol = audioPlayer.volume;
                const fadeOut = setInterval(() => {
                    if (vol > 0.02) {
                        vol -= 0.02;
                        audioPlayer.volume = vol;
                    } else {
                        clearInterval(fadeOut);
                        audioPlayer.pause();
                        isMusicPlaying = false;
                        musicBtn.classList.remove('music-active');
                        musicBtn.querySelector('.btn-text').textContent = 'Reproducir';
                        musicBtn.querySelector('.btn-icon').textContent = '🎵';
                    }
                }, 50);
            } else {
                // Reproducir música con fade in
                audioPlayer.play();
                audioPlayer.volume = 0;
                isMusicPlaying = true;
                musicBtn.classList.add('music-active');
                musicBtn.querySelector('.btn-text').textContent = 'Pausar';
                musicBtn.querySelector('.btn-icon').textContent = '♫';
                
                let vol = 0;
                const fadeIn = setInterval(() => {
                    if (vol < 0.5) {
                        vol += 0.01;
                        audioPlayer.volume = vol;
                    } else {
                        clearInterval(fadeIn);
                    }
                }, 50);
            }
        }
        
        function createCat() {
            cat = new THREE.Group();
            
            // Cuerpo
            const bodyGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            bodyGeometry.scale(1.5, 1, 1.2);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x151515,
                roughness: 0.8
            });
            
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.position.y = 1.5;
            cat.add(body);
            
            // Cabeza
            const headGeometry = new THREE.SphereGeometry(1, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0x151515,
                roughness: 0.7
            });
            
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.castShadow = true;
            head.position.set(1.5, 2.5, 0);
            cat.add(head);
            
            // Orejas
            const earGeometry = new THREE.ConeGeometry(0.4, 0.8, 4);
            const earMaterial = new THREE.MeshStandardMaterial({
                color: 0x0d0d0d,
                roughness: 0.9
            });
            
            const earLeft = new THREE.Mesh(earGeometry, earMaterial);
            earLeft.castShadow = true;
            earLeft.position.set(1.7, 3.3, -0.5);
            earLeft.rotation.z = -Math.PI / 4;
            cat.add(earLeft);
            
            const earRight = new THREE.Mesh(earGeometry, earMaterial);
            earRight.castShadow = true;
            earRight.position.set(1.7, 3.3, 0.5);
            earRight.rotation.z = -Math.PI / 4;
            cat.add(earRight);
            
            // Ojos
            const eyeGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const eyeMaterial = new THREE.MeshStandardMaterial({
                color: 0xd4af37,
                roughness: 0.3,
                metalness: 0.4,
                emissive: 0x554411,
                emissiveIntensity: 0.5
            });
            
            const eyeLeft = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eyeLeft.position.set(2.1, 2.7, -0.4);
            cat.add(eyeLeft);
            
            const eyeRight = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eyeRight.position.set(2.1, 2.7, 0.4);
            cat.add(eyeRight);
            
            // Cola
            const tailCurve = new THREE.CubicBezierCurve3(
                new THREE.Vector3(-1.5, 1.5, 0),
                new THREE.Vector3(-3, 2, 0),
                new THREE.Vector3(-3.5, 3, 0),
                new THREE.Vector3(-2.5, 4, 0)
            );
            
            const tailGeometry = new THREE.TubeGeometry(tailCurve, 20, 0.2, 8, false);
            const tailMaterial = new THREE.MeshStandardMaterial({
                color: 0x0d0d0d,
                roughness: 0.8
            });
            
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.castShadow = true;
            cat.add(tail);
            
            // Posicionar el gato
            cat.position.set(0, 0, 10);
            cat.scale.set(0.8, 0.8, 0.8);
            scene.add(cat);
        }
        
        // Crear partículas (corazones que flotan)
        function createParticles() {
            // Crear geometría de corazón
            const heartShape = new THREE.Shape();
            const x = 0, y = 0;
            
            heartShape.moveTo(x, y + 1);
            heartShape.bezierCurveTo(x + 1, y + 1, x + 1.5, y, x, y - 1);
            heartShape.bezierCurveTo(x - 1.5, y, x - 1, y + 1, x, y + 1);
            
            const heartGeometry = new THREE.ExtrudeGeometry(heartShape, {
                depth: 0.2,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.2,
                bevelSegments: 3
            });
            
            // Crear varios corazones flotantes
            for (let i = 0; i < 30; i++) {
                const heartMaterial = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(
                        0.9 + Math.random() * 0.1,
                        0.1 + Math.random() * 0.1,
                        0.1 + Math.random() * 0.1
                    ),
                    roughness: 0.3,
                    metalness: 0.2,
                    transparent: true,
                    opacity: 0.7 + Math.random() * 0.3,
                    side: THREE.DoubleSide
                });
                
                const heart = new THREE.Mesh(heartGeometry, heartMaterial);
                heart.scale.set(0.1, 0.1, 0.1);
                
                heart.position.set(
                    THREE.MathUtils.randFloatSpread(60),
                    2 + Math.random() * 10,
                    THREE.MathUtils.randFloatSpread(60)
                );
                
                heart.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                
                // Propiedades para animación
                heart.userData = {
                    rotSpeed: (Math.random() - 0.5) * 0.02,
                    floatSpeed: 0.2 + Math.random() * 0.3,
                    floatHeight: 1 + Math.random() * 2,
                    originalY: heart.position.y,
                    floatOffset: Math.random() * Math.PI * 2
                };
                
                hearts.push(heart);
                scene.add(heart);
            }
        }
        
        // Configurar controles para explorar la escena
        function setupControls() {
            // Variables para el control de la cámara con el ratón
            let isMouseDown = false;
            let mouseX = 0;
            let mouseY = 0;
            let targetRotationX = 0;
            let targetRotationY = 0;
            let currentRotationX = 0;
            let currentRotationY = 0;
            
            // Variables para el movimiento con teclado
            const keys = {
                w: false,
                a: false,
                s: false,
                d: false
            };
            
            // Eventos de ratón
            document.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            document.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            document.addEventListener('mousemove', (event) => {
                if (isMouseDown) {
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                    
                    targetRotationX -= deltaX * 0.01;
                    targetRotationY = Math.max(-Math.PI/4, Math.min(Math.PI/4, targetRotationY - deltaY * 0.01));
                }
            });
            
            // Eventos de teclado
            document.addEventListener('keydown', (event) => {
                switch (event.key.toLowerCase()) {
                    case 'w': keys.w = true; break;
                    case 'a': keys.a = true; break;
                    case 's': keys.s = true; break;
                    case 'd': keys.d = true; break;
                    case 'e': 
                        document.getElementById('centeredCard').style.display = 
                            document.getElementById('centeredCard').style.display === 'flex' ? 'none' : 'flex';
                        break;
                }
            });
            
            document.addEventListener('keyup', (event) => {
                switch (event.key.toLowerCase()) {
                    case 'w': keys.w = false; break;
                    case 'a': keys.a = false; break;
                    case 's': keys.s = false; break;
                    case 'd': keys.d = false; break;
                }
            });
            
            // Función para actualizar la posición de la cámara
            window.updateCamera = function(delta) {
                // Suavizar la rotación
                currentRotationX += (targetRotationX - currentRotationX) * 0.1;
                currentRotationY += (targetRotationY - currentRotationY) * 0.1;
                
                // Aplicar rotación
                camera.rotation.order = 'YXZ';
                camera.rotation.y = currentRotationX;
                camera.rotation.x = currentRotationY;
                
                // Movimiento basado en teclado
                const speed = 10 * delta;
                const direction = new THREE.Vector3();
                
                // Obtener la dirección frontal (excluir el componente Y para mantener el movimiento en el plano horizontal)
                const frontVector = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                frontVector.y = 0;
                frontVector.normalize();
                
                // Obtener la dirección lateral
                const rightVector = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                rightVector.y = 0;
                rightVector.normalize();
                
                // Aplicar las direcciones según las teclas presionadas
                if (keys.w) direction.add(frontVector);
                if (keys.s) direction.sub(frontVector);
                if (keys.a) direction.sub(rightVector);
                if (keys.d) direction.add(rightVector);
                
                // Normalizar la dirección si hay movimiento
                if (direction.length() > 0) {
                    direction.normalize();
                    camera.position.addScaledVector(direction, speed);
                    
                    // Limitar el movimiento dentro de un área
                    camera.position.x = Math.max(-50, Math.min(50, camera.position.x));
                    camera.position.z = Math.max(-50, Math.min(50, camera.position.z));
                    
                    // Mantener la altura
                    camera.position.y = 5;
                }
            };
        }
        
        // Redimensionar la ventana
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Animación de la escena
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            // Actualizar animaciones con TWEEN
            TWEEN.update();
            
            // Actualizar la cámara
            window.updateCamera(delta);
            
            // Animación del sol
            if (sun) {
                sun.children[0].scale.x = 1 + Math.sin(clock.getElapsedTime() * 0.5) * 0.1;
                sun.children[0].scale.y = 1 + Math.sin(clock.getElapsedTime() * 0.5) * 0.1;
                sun.children[0].scale.z = 1 + Math.sin(clock.getElapsedTime() * 0.5) * 0.1;
            }
            
            // Animación de las palmeras
            if (palmGroup) {
                palmGroup.children.forEach((palm, i) => {
                    palm.children.forEach((part, j) => {
                        if (j > 0) { // Solo las hojas
                            part.rotation.z += Math.sin(clock.getElapsedTime() * 0.5 + i * 0.1) * 0.002;
                            part.rotation.y += Math.sin(clock.getElapsedTime() * 0.3 + i * 0.1) * 0.001;
                        }
                    });
                });
            }
            
            // Animación de las flores
            if (flowerField) {
                flowerField.children.forEach((flower, i) => {
                    flower.rotation.y = Math.sin(clock.getElapsedTime() * 0.3 + i * 0.1) * 0.05;
                    flower.position.y = Math.sin(clock.getElapsedTime() * 0.5 + i * 0.3) * 0.1;
                });
            }
            
            // Animación del gato
            if (cat) {
                cat.children[cat.children.length - 1].rotation.z = Math.sin(clock.getElapsedTime() * 2) * 0.2; // Cola
                cat.rotation.y = Math.sin(clock.getElapsedTime() * 0.5) * 0.1; // Cuerpo girando suavemente
            }
            
            // Animación de los corazones
            hearts.forEach(heart => {
                const userData = heart.userData;
                
                // Rotación
                heart.rotation.x += userData.rotSpeed;
                heart.rotation.y += userData.rotSpeed * 1.5;
                
                // Movimiento flotante
                heart.position.y = userData.originalY + 
                    Math.sin(clock.getElapsedTime() * userData.floatSpeed + userData.floatOffset) * 
                    userData.floatHeight;
            });
            
            // Animación de la pantalla digital
            if (digitalScreen && digitalScreen.visible) {
                // Hacer que la pantalla tenga un suave efecto de resplandor
                if (digitalScreen.children[0].material) {
                    const pulseFactor = (Math.sin(clock.getElapsedTime() * 2) + 1) * 0.5;
                    digitalScreen.children[0].material.emissiveIntensity = 0.1 + pulseFactor * 0.3;
                }
            }
            
            renderer.render(scene, camera);
        }
        
        // Cerrar el modal inicial
        function closeModal() {
            document.getElementById("myModal").style.display = "none";
            setupAudio();
            document.getElementById('audioPlayer').play();
        }
        
        // Ya no necesitamos esta función pues ahora usamos la pantalla 3D
        function closeCard() {
            document.getElementById("centeredCard").style.display = "none";
        }
        
        // Teclas para controlar la escena
        document.addEventListener('keydown', function(event) {
            // 'P' para mostrar/ocultar la pantalla digital
            if (event.key.toLowerCase() === 'p') {
                toggleScreen();
            }
            
            // 'M' para controlar la música
            if (event.key.toLowerCase() === 'm') {
                toggleMusic();
            }
            
            // Atajos adicionales
            if (event.key === 'Escape') {
                // Cerrar cualquier modal o pantalla
                if (document.getElementById("myModal").style.display === "block") {
                    closeModal();
                } else if (isScreenVisible) {
                    toggleScreen();
                }
            }
        });
        
        // Iniciar todo cuando se carga la página
        window.onload = function() {
            init();
            
            // Mostrar mensaje principal después de cargar
            setTimeout(() => {
                document.getElementById("myModal").style.display = "block";
            }, 2500);
            
            // Actualizar el texto de ayuda
            document.querySelector('.controls-hint').innerHTML = 
                'WASD: Moverte | Ratón: Mirar | P: Mensaje | M: Música | ↑↓: Desplazar texto';
                
            // Auto-mostrar la pantalla digital después de cerrar el modal
            setTimeout(() => {
                if (!isScreenVisible) {
                    toggleScreen();
                }
            }, 5000);
        };


        // Detectar si es un dispositivo móvil
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // Si es un dispositivo móvil, añadir el texto de ayuda para móviles
    if (isMobile) {
        const mobileHint = document.createElement('div');
        mobileHint.className = 'mobile-controls-hint';
        mobileHint.innerHTML = 'Desliza para mirar alrededor y usa el joystick para moverte';
        document.body.appendChild(mobileHint);
        
        // Ocultar el hint después de 5 segundos
        setTimeout(() => {
            mobileHint.style.opacity = '0';
            setTimeout(() => {
                mobileHint.style.display = 'none';
            }, 1000);
        }, 5000);
    }
    
    // Configuración del joystick virtual
    function setupMobileControls() {
        // Referencias a elementos del DOM
        const joystickBase = document.getElementById('joystick-base');
        const joystickThumb = document.getElementById('joystick-thumb');
        const mobileMessageBtn = document.getElementById('mobile-message');
        const mobileMusicBtn = document.getElementById('mobile-music');
        
        // Variables para el joystick
        let joystickActive = false;
        let joystickOrigin = { x: 0, y: 0 };
        let currentPosition = { x: 0, y: 0 };
        let joystickVector = { x: 0, y: 0 };
        
        // Variables para el control de vista
        let touchStartX = 0;
        let touchStartY = 0;
        let touchActive = false;
        
        // Configurar el joystick
        function initJoystick() {
            const baseRect = joystickBase.getBoundingClientRect();
            joystickOrigin = {
                x: baseRect.left + baseRect.width / 2,
                y: baseRect.top + baseRect.height / 2
            };
            joystickThumb.style.transform = 'translate(0px, 0px)';
        }
        
        // Actualizar visualmente el joystick
        function updateJoystickThumb() {
            // Calcular el vector del joystick
            const dx = currentPosition.x - joystickOrigin.x;
            const dy = currentPosition.y - joystickOrigin.y;
            
            // Limitar el movimiento dentro del radio del joystick
            const maxDistance = joystickBase.offsetWidth / 2;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > maxDistance) {
                const angle = Math.atan2(dy, dx);
                const limitedX = Math.cos(angle) * maxDistance;
                const limitedY = Math.sin(angle) * maxDistance;
                
                joystickThumb.style.transform = `translate(${limitedX}px, ${limitedY}px)`;
                
                // Calcular vector normalizado para el movimiento (entre -1 y 1)
                joystickVector = {
                    x: limitedX / maxDistance,
                    y: limitedY / maxDistance
                };
            } else {
                joystickThumb.style.transform = `translate(${dx}px, ${dy}px)`;
                
                // Calcular vector normalizado para el movimiento (entre -1 y 1)
                joystickVector = {
                    x: dx / maxDistance,
                    y: dy / maxDistance
                };
            }
        }
        
        // Registrar cuando el joystick se activa
        joystickBase.addEventListener('touchstart', (e) => {
            e.preventDefault();
            joystickActive = true;
            const touch = e.touches[0];
            currentPosition = { x: touch.clientX, y: touch.clientY };
            updateJoystickThumb();
        });
        
        // Registrar cuando el joystick se mueve
        document.addEventListener('touchmove', (e) => {
            // Solo procesar si hay toques
            if (e.touches.length === 0) return;
            
            // Encontrar qué dedo está controlando el joystick y cuál está controlando la vista
            for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                const touchX = touch.clientX;
                const touchY = touch.clientY;
                
                // Comprobar si este toque está en el joystick
                const joystickRect = joystickBase.getBoundingClientRect();
                const inJoystick = (
                    touchX >= joystickRect.left - 50 &&
                    touchX <= joystickRect.right + 50 &&
                    touchY >= joystickRect.top - 50 &&
                    touchY <= joystickRect.bottom + 50
                );
                
                if (inJoystick && joystickActive) {
                    // Este toque es para el joystick
                    currentPosition = { x: touchX, y: touchY };
                    updateJoystickThumb();
                } else if (!inJoystick) {
                    // Este toque es para la cámara
                    if (!touchActive) {
                        touchActive = true;
                        touchStartX = touchX;
                        touchStartY = touchY;
                    } else {
                        // Calcular deltas para la rotación de la cámara
                        const deltaX = touchX - touchStartX;
                        const deltaY = touchY - touchStartY;
                        
                        // Actualizar la rotación objetivo de la cámara
                        targetRotationX -= deltaX * 0.01;
                        targetRotationY = Math.max(-Math.PI/4, Math.min(Math.PI/4, targetRotationY - deltaY * 0.01));
                        
                        // Actualizar posición inicial para el próximo movimiento
                        touchStartX = touchX;
                        touchStartY = touchY;
                    }
                }
            }
        });
        
        // Registrar cuando el joystick se suelta
        document.addEventListener('touchend', (e) => {
            // Comprobar si todos los dedos se han levantado
            if (e.touches.length === 0) {
                // Resetear el joystick
                joystickActive = false;
                joystickThumb.style.transform = 'translate(0px, 0px)';
                joystickVector = { x: 0, y: 0 };
                
                // Resetear el control de la cámara
                touchActive = false;
            } else {
                // Comprobar si el dedo del joystick se ha levantado
                let joystickTouchActive = false;
                for (let i = 0; i < e.touches.length; i++) {
                    const touch = e.touches[i];
                    const joystickRect = joystickBase.getBoundingClientRect();
                    const inJoystick = (
                        touch.clientX >= joystickRect.left - 50 &&
                        touch.clientX <= joystickRect.right + 50 &&
                        touch.clientY >= joystickRect.top - 50 &&
                        touch.clientY <= joystickRect.bottom + 50
                    );
                    
                    if (inJoystick) {
                        joystickTouchActive = true;
                    }
                }
                
                if (!joystickTouchActive) {
                    joystickActive = false;
                    joystickThumb.style.transform = 'translate(0px, 0px)';
                    joystickVector = { x: 0, y: 0 };
                }
            }
        });
        
        // Botones para controlar el mensaje y la música
        mobileMessageBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            toggleScreen();
        });
        
        mobileMusicBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            toggleMusic();
        });
        
        // Modificar la función updateCamera para usar el joystick en móviles
        const originalUpdateCamera = window.updateCamera;
        window.updateCamera = function(delta) {
            // Llamar a la función original para controles de teclado en PC
            originalUpdateCamera(delta);
            
            // Añadir movimiento basado en el joystick para móviles
            if (isMobile && (joystickVector.x !== 0 || joystickVector.y !== 0)) {
                const speed = 10 * delta;
                const direction = new THREE.Vector3();
                
                // Obtener la dirección frontal (excluir el componente Y para mantener el movimiento en el plano horizontal)
                const frontVector = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                frontVector.y = 0;
                frontVector.normalize();
                
                // Obtener la dirección lateral
                const rightVector = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                rightVector.y = 0;
                rightVector.normalize();
                
                // Aplicar las direcciones según el joystick
                direction.add(frontVector.clone().multiplyScalar(-joystickVector.y));
                direction.add(rightVector.clone().multiplyScalar(joystickVector.x));
                
                // Normalizar la dirección si hay movimiento
                if (direction.length() > 0) {
                    direction.normalize();
                    camera.position.addScaledVector(direction, speed);
                    
                    // Limitar el movimiento dentro de un área
                    camera.position.x = Math.max(-50, Math.min(50, camera.position.x));
                    camera.position.z = Math.max(-50, Math.min(50, camera.position.z));
                    
                    // Mantener la altura
                    camera.position.y = 5;
                }
            }
        };
        
        // Inicializar el joystick
        window.addEventListener('resize', initJoystick);
        initJoystick();
    }
    
    // Inicializar controles móviles cuando se carga la página
    document.addEventListener('DOMContentLoaded', () => {
        if (isMobile) {
            setupMobileControls();
        }
    });

    </script>
    <!-- Añade este código justo antes del cierre del body (antes de </body>) -->

<!-- Controles móviles -->
<div id="mobile-controls" class="mobile-controls">
    <div class="joystick-container">
        <div id="joystick-base" class="joystick-base">
            <div id="joystick-thumb" class="joystick-thumb"></div>
        </div>
    </div>
    <div class="mobile-buttons">
        <button id="mobile-message" class="mobile-btn">
            <span class="mobile-btn-icon">💌</span>
        </button>
        <button id="mobile-music" class="mobile-btn">
            <span class="mobile-btn-icon">🎵</span>
        </button>
    </div>
</div>
</body>
</html>