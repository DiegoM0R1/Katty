<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Para Katty de tu Cholasho‚ù§Ô∏è - Versi√≥n 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            color: white;
            background: #000;
        }
        
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        .centered-card {
            display: none;
            justify-content: center;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        .card-content {
            background: linear-gradient(135deg, #ff7f50, #ff4757);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            color: white;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5),
                        0 0 100px rgba(255, 79, 87, 0.6),
                        inset 0 0 20px rgba(255, 255, 255, 0.2);
            width: 80%;
            max-width: 800px;
            height: auto;
            max-height: 90%;
            overflow-y: auto;
            animation: fadeIn 1s ease-out, float 6s ease-in-out infinite;
            transform-style: preserve-3d;
            perspective: 1000px;
        }

        .card-content p {
            font-size: 18px;
            line-height: 1.8;
            margin: 0;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
            transform: translateZ(20px);
        }

        .close {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 30px;
            color: white;
            cursor: pointer;
            transition: all 0.4s;
            z-index: 10;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .close:hover {
            transform: scale(1.3) rotate(90deg);
            text-shadow: 0 0 20px rgba(255, 255, 255, 1);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.8) rotateX(-10deg);
            }
            to {
                opacity: 1;
                transform: scale(1) rotateX(0);
            }
        }
        
        @keyframes float {
            0%, 100% {
                transform: translateY(0) rotateX(0deg);
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5),
                            0 0 100px rgba(255, 79, 87, 0.6);
            }
            50% {
                transform: translateY(-15px) rotateX(3deg);
                box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3),
                            0 0 120px rgba(255, 79, 87, 0.8);
            }
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
        }

        .modal-content {
            position: relative;
            margin: 15% auto;
            padding: 30px;
            width: 90%;
            max-width: 500px;
            background: linear-gradient(135deg, #ff7f50, #ff4757);
            border-radius: 20px;
            text-align: center;
            color: white;
            box-shadow: 0 15px 50px rgba(0,0,0,0.5),
                        0 0 100px rgba(255, 100, 100, 0.4);
            animation: modalAppear 0.8s cubic-bezier(0.17, 0.89, 0.32, 1.25);
            transform-style: preserve-3d;
        }
        
        .modal-content::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, 
                rgba(255, 255, 255, 0.1), 
                rgba(255, 255, 255, 0.3), 
                rgba(255, 255, 255, 0.1), 
                rgba(255, 255, 255, 0.3));
            z-index: -1;
            border-radius: 22px;
            animation: borderGlow 3s linear infinite;
        }

        @keyframes borderGlow {
            0%, 100% {
                opacity: 0.8;
            }
            50% {
                opacity: 0.3;
            }
        }

        @keyframes modalAppear {
            from {
                transform: scale(0.5) rotateX(-30deg);
                opacity: 0;
            }
            to {
                transform: scale(1) rotateX(0);
                opacity: 1;
            }
        }

        .modal-content p {
            font-size: 24px;
            margin: 0;
            text-shadow: 2px 2px 6px rgba(0,0,0,0.4);
            transform: translateZ(30px);
        }
        
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #ff4757, #ff7f50);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 1s ease-out;
        }
        
        .loading-text {
            font-size: 24px;
            margin-top: 20px;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            animation: pulse 1.5s infinite;
        }
        
        .loading-heart {
            font-size: 50px;
            animation: heartbeat 1.2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes heartbeat {
            0% { transform: scale(1); }
            15% { transform: scale(1.3); }
            30% { transform: scale(1); }
            45% { transform: scale(1.3); }
            60% { transform: scale(1); }
            100% { transform: scale(1); }
        }
        
        .controls-hint {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.6);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 14px;
            opacity: 0.7;
            z-index: 100;
            transition: opacity 0.3s;
        }
        
        .controls-hint:hover {
            opacity: 1;
        }
        
        /* Estilos para los controles de la pantalla digital */
        .screen-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .control-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255, 79, 87, 0.8);
            border: none;
            border-radius: 12px;
            padding: 10px;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }
        
        .control-btn:hover {
            background: rgba(255, 127, 80, 0.9);
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .btn-icon {
            font-size: 24px;
            margin-bottom: 5px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .btn-text {
            font-size: 12px;
            font-weight: bold;
        }
        
        /* Indicador de m√∫sica activa */
        .music-active .btn-icon {
            animation: pulse 1s infinite alternate;
        }
        
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.2); }
        }
        /* Estilos para controles m√≥viles */
    .mobile-controls {
        display: none; /* Oculto por defecto, se muestra en dispositivos m√≥viles */
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 30vh;
        z-index: 900;
        touch-action: none;
    }
    
    .joystick-container {
        position: absolute;
        bottom: 20px;
        left: 20px;
        width: 120px;
        height: 120px;
    }
    
    .joystick-base {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
        border: 2px solid rgba(255, 255, 255, 0.3);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }
    
    .joystick-thumb {
        width: 50%;
        height: 50%;
        background: rgba(255, 79, 87, 0.8);
        border-radius: 50%;
        position: relative;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
        transition: transform 0.1s ease;
    }
    
    .mobile-buttons {
        position: absolute;
        bottom: 40px;
        right: 20px;
        display: flex;
        gap: 15px;
    }
    
    .mobile-btn {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: rgba(255, 79, 87, 0.8);
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 24px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(5px);
    }
    
    .mobile-btn:active {
        transform: scale(0.9);
    }
    
    .mobile-btn-icon {
        font-size: 30px;
        text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }
    
    /* Texto de ayuda para m√≥viles */
    .mobile-controls-hint {
        position: fixed;
        top: 20px;
        left: 0;
        width: 100%;
        text-align: center;
        background: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 10px;
        font-size: 14px;
        z-index: 100;
        display: none;
        backdrop-filter: blur(5px);
    }
    
    /* Responsividad para m√≥viles */
    @media (max-width: 768px) {
        .controls-hint {
            display: none; /* Ocultar controles de PC */
        }
        
        .screen-controls {
            display: none; /* Ocultar controles de PC */
        }
        
        .mobile-controls {
            display: block; /* Mostrar controles m√≥viles */
        }
        
        .mobile-controls-hint {
            display: block; /* Mostrar ayuda para m√≥viles */
        }
    }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-heart">‚ù§Ô∏è</div>
        <div class="loading-text">Cargando nuestro mundo...</div>
    </div>
    
    <div class="controls-hint">Usa el rat√≥n para mirar alrededor y las teclas WASD para moverte</div>
    
    <!-- Reemplazamos la tarjeta centrada con la pantalla digital 3D que se manejar√° en Three.js -->
    <div id="screenControls" class="screen-controls">
        <button id="toggleScreen" class="control-btn">
            <span class="btn-icon">üíå</span>
            <span class="btn-text">Mostrar Mensaje</span>
        </button>
        <button id="toggleMusic" class="control-btn">
            <span class="btn-icon">üéµ</span>
            <span class="btn-text">M√∫sica</span>
        </button>
    </div>

    <div id="myModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <p>Amooooooooor e construido este mundito para ti<3</p>
        </div>
    </div>

    <audio id="audioPlayer" src="Daft Punk - Touch (Choral Version from Epilogue - Extended).mp3" preload="auto" style="display:none"></audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.min.js"></script>
    <script>
        // Variables principales
        let scene, camera, renderer, composer;
        let sun, palmGroup, flowerField, cat, hearts = [];
        let clock = new THREE.Clock();
        const loader = new THREE.TextureLoader();
        
        // Manejo de audio con un efecto de fade in
        function setupAudio() {
            const audioElement = document.getElementById('audioPlayer');
            // Usamos la ruta original del archivo
            // Ya est√° definida en el elemento audio como "Daft Punk - Touch (Choral Version from Epilogue - Extended).mp3"
            audioElement.loop = true;
            audioElement.volume = 0;
            
            // Hacemos un fade in del volumen
            let vol = 0;
            const intervalId = setInterval(() => {
                if (vol < 0.5) {
                    vol += 0.01;
                    audioElement.volume = vol;
                } else {
                    clearInterval(intervalId);
                }
            }, 100);
            
            // Marcamos que la m√∫sica est√° reproduci√©ndose
            isMusicPlaying = true;
            const musicBtn = document.getElementById('toggleMusic');
            if (musicBtn) {
                musicBtn.classList.add('music-active');
                musicBtn.querySelector('.btn-text').textContent = 'Pausar';
                musicBtn.querySelector('.btn-icon').textContent = '‚ô´';
            }
        }
        
        // Inicializar la escena
        function init() {
            // Crear escena
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0xff7e57, 0.02);
            
            // Configurar c√°mara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 20);
            camera.lookAt(0, 5, 0);
            
            // Configurar renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);
            
            // A√±adir luz ambiental para iluminaci√≥n general
            const ambientLight = new THREE.AmbientLight(0xffd4b3, 0.5);
            scene.add(ambientLight);
            
            // Crear elementos de la escena
            createSkybox();
            createSun();
            createGround();
            createPalms();
            createFlowers();
            createCat();
            createParticles();
            createDigitalScreen();
            
            // Configurar eventos y controles
            setupControls();
            setupScreenControls();
            window.addEventListener('resize', onWindowResize);
            
            // Ocultar la pantalla de carga despu√©s de inicializar todo
            setTimeout(() => {
                document.getElementById('loadingScreen').style.opacity = 0;
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    document.getElementById('myModal').style.display = 'block';
                }, 1000);
            }, 1500);
            
            // Iniciar la animaci√≥n
            animate();
        }
        
        function setupScreenControls() {
            // Configurar los controles de la pantalla digital
            document.getElementById('toggleScreen').addEventListener('click', toggleScreen);
            document.getElementById('toggleMusic').addEventListener('click', toggleMusic);
            
            // Configurar controles de scroll para la pantalla
            document.addEventListener('keydown', (event) => {
                if (isScreenVisible) {
                    if (event.key === 'ArrowUp') {
                        // Scroll hacia arriba en el texto
                        window.screenTextOffset = Math.max(0, window.screenTextOffset - 1);
                    } else if (event.key === 'ArrowDown') {
                        // Scroll hacia abajo en el texto
                        window.screenTextOffset = Math.min(13, window.screenTextOffset + 1);
                    }
                }
            });
        }
        
        // Crear el skybox (cielo)
        function createSkybox() {
            // Creamos un gradiente de cielo con geometr√≠a
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            
            // Material para el cielo con gradiente de atardecer
            const uniforms = {
                topColor: { value: new THREE.Color(0xff0026) },
                bottomColor: { value: new THREE.Color(0x004ac9) },
                offset: { value: 50 },
                exponent: { value: 0.6 }
            };
            
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
            
            // A√±adir estrellas al cielo
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.7,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            const starsVertices = [];
            for (let i = 0; i < 1000; i++) {
                const x = THREE.MathUtils.randFloatSpread(600);
                const y = THREE.MathUtils.randFloat(50, 250); // Estrellas solo en la parte superior
                const z = THREE.MathUtils.randFloatSpread(600);
                starsVertices.push(x, y, z);
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);
        }
        
        // Crear el sol
        function createSun() {
            const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xff5500,
                transparent: true,
                opacity: 0.9
            });
            
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(0, 60, -150);
            scene.add(sun);
            
            // A√±adir resplandor al sol
            const sunLightGeometry = new THREE.SphereGeometry(15, 32, 32);
            const sunLightMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.5
            });
            
            const sunGlow = new THREE.Mesh(sunLightGeometry, sunLightMaterial);
            sun.add(sunGlow);
            
            // Luz direccional para simular la luz del sol
            const sunLight = new THREE.DirectionalLight(0xfffaf0, 1);
            sunLight.position.set(0, 100, -150);
            sunLight.castShadow = true;
            sunLight.shadow.camera.far = 300;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            sunLight.shadow.mapSize.width = 1024;
            sunLight.shadow.mapSize.height = 1024;
            scene.add(sunLight);
        }
        
        // Crear el suelo
        function createGround() {
            // Arena
            const sandGeometry = new THREE.PlaneGeometry(1000, 1000);
            const sandMaterial = new THREE.MeshStandardMaterial({
                color: 0xd4b94b,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const sand = new THREE.Mesh(sandGeometry, sandMaterial);
            sand.rotation.x = -Math.PI / 2;
            sand.position.y = -1;
            sand.receiveShadow = true;
            scene.add(sand);
            
            // Agua
            const waterGeometry = new THREE.PlaneGeometry(1000, 800);
            const waterMaterial = new THREE.MeshStandardMaterial({
                color: 0x0088ff,
                roughness: 0.1,
                metalness: 0.6,
                transparent: true,
                opacity: 0.8
            });
            
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = -0.5;
            water.position.z = -300;
            scene.add(water);
        }
        
        // Crear palmeras
        function createPalms() {
            palmGroup = new THREE.Group();
            scene.add(palmGroup);
            
            // Funci√≥n para crear una sola palmera
            function createPalm(x, z, scaleVal = 1, rotY = 0) {
                const palm = new THREE.Group();
                
                // Tronco
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 15, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.9,
                    metalness: 0.1
                });
                
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.castShadow = true;
                trunk.position.y = 7.5;
                
                // Inclinaci√≥n aleatoria del tronco
                trunk.rotation.x = THREE.MathUtils.randFloatSpread(0.1);
                trunk.rotation.z = THREE.MathUtils.randFloatSpread(0.1);
                
                palm.add(trunk);
                
                // Hojas
                const leafShape = new THREE.Shape();
                leafShape.moveTo(0, 0);
                leafShape.bezierCurveTo(2, 1, 8, 1.5, 10, 0);
                leafShape.bezierCurveTo(8, -1.5, 2, -1, 0, 0);
                
                const extrudeSettings = {
                    depth: 0.1,
                    bevelEnabled: true,
                    bevelThickness: 0.1,
                    bevelSize: 0.1,
                    bevelSegments: 3
                };
                
                const leafGeometry = new THREE.ExtrudeGeometry(leafShape, extrudeSettings);
                const leafMaterial = new THREE.MeshStandardMaterial({
                    color: 0x00aa00,
                    roughness: 0.8,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                });
                
                // Crear varias hojas y posicionarlas
                for (let i = 0; i < 7; i++) {
                    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                    leaf.castShadow = true;
                    leaf.rotation.z = (i * Math.PI / 3.5);
                    leaf.rotation.y = (i * Math.PI / 7);
                    leaf.position.y = 15;
                    leaf.scale.set(1, 1 + Math.random() * 0.5, 1);
                    palm.add(leaf);
                }
                
                // Posicionar la palmera completa
                palm.position.set(x, 0, z);
                palm.rotation.y = rotY;
                palm.scale.set(scaleVal, scaleVal, scaleVal);
                
                return palm;
            }
            
            // Distribuir varias palmeras
            const palmPositions = [
                { x: -25, z: 0, scale: 1.2, rotY: Math.PI/4 },
                { x: -18, z: 8, scale: 0.9, rotY: Math.PI/3 },
                { x: 25, z: 5, scale: 1.1, rotY: -Math.PI/5 },
                { x: 20, z: -8, scale: 0.8, rotY: -Math.PI/6 },
                { x: -12, z: -15, scale: 1, rotY: Math.PI/8 },
                { x: 15, z: -18, scale: 1.3, rotY: -Math.PI/9 },
                { x: -30, z: -25, scale: 1.5, rotY: Math.PI/7 },
                { x: 30, z: -30, scale: 1.4, rotY: -Math.PI/8 }
            ];
            
            palmPositions.forEach(pos => {
                const palm = createPalm(pos.x, pos.z, pos.scale, pos.rotY);
                palmGroup.add(palm);
            });
        }
        
        // Crear flores
        function createFlowers() {
            flowerField = new THREE.Group();
            scene.add(flowerField);
            
            // Funci√≥n para crear una flor
            function createFlower(x, z, scale = 1, color = 0xffc400) {
                const flower = new THREE.Group();
                
                // Tallo
                const stemGeometry = new THREE.CylinderGeometry(0.1, 0.15, 3, 8);
                const stemMaterial = new THREE.MeshStandardMaterial({
                    color: 0x2ecc71,
                    roughness: 0.8
                });
                
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                stem.castShadow = true;
                stem.position.y = 1.5;
                flower.add(stem);
                
                // Centro de la flor
                const centerGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const centerMaterial = new THREE.MeshStandardMaterial({
                    color: 0x23200a,
                    roughness: 0.9
                });
                
                const center = new THREE.Mesh(centerGeometry, centerMaterial);
                center.castShadow = true;
                center.position.y = 3.2;
                flower.add(center);
                
                // P√©talos
                const petalGeometry = new THREE.ConeGeometry(0.8, 1.5, 4);
                const petalMaterial = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.6,
                    metalness: 0.1
                });
                
                // Crear p√©talos alrededor del centro
                for (let i = 0; i < 8; i++) {
                    const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                    petal.castShadow = true;
                    
                    // Posicionar alrededor del centro
                    const angle = (i / 8) * Math.PI * 2;
                    petal.position.set(
                        Math.cos(angle) * 0.6,
                        3.2,
                        Math.sin(angle) * 0.6
                    );
                    
                    // Apuntar hacia afuera
                    petal.lookAt(
                        Math.cos(angle) * 10,
                        3.2,
                        Math.sin(angle) * 10
                    );
                    
                    // Rotar para que el cono apunte hacia afuera
                    petal.rotateX(Math.PI / 2);
                    
                    flower.add(petal);
                }
                
                // Posicionar la flor completa
                flower.position.set(x, 0, z);
                flower.scale.set(scale, scale, scale);
                
                return flower;
            }
            
            // Distribuir m√∫ltiples flores
            const flowerColors = [0xffc400, 0xff9500, 0xff5f00, 0xffcc00, 0xff8800];
            
            for (let i = 0; i < 80; i++) {
                const x = THREE.MathUtils.randFloatSpread(60);
                const z = THREE.MathUtils.randFloatSpread(60);
                const scale = 0.3 + Math.random() * 0.3;
                const colorIndex = Math.floor(Math.random() * flowerColors.length);
                
                // Evitar colocar flores muy cerca de las palmeras
                let tooClose = false;
                palmGroup.children.forEach(palm => {
                    const dx = palm.position.x - x;
                    const dz = palm.position.z - z;
                    const distSq = dx * dx + dz * dz;
                    if (distSq < 25) { // 5 al cuadrado
                        tooClose = true;
                    }
                });
                
                if (!tooClose) {
                    const flower = createFlower(x, z, scale, flowerColors[colorIndex]);
                    flowerField.add(flower);
                }
            }
        }
        
        // Crear el gato
        // Pantalla digital 3D
        let digitalScreen;
        let isScreenVisible = false;
        let isMusicPlaying = false;
        
        function createDigitalScreen() {
            // Grupo principal para la pantalla
            digitalScreen = new THREE.Group();
            
            // Crear el marco de la pantalla (m√°s grande)
            const frameGeometry = new THREE.BoxGeometry(30, 20, 0.5);
            const frameMaterial = new THREE.MeshStandardMaterial({
                color: 0xff4757,
                roughness: 0.2,
                metalness: 0.8,
                emissive: 0xff4757,
                emissiveIntensity: 0.2
            });
            
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.castShadow = true;
            frame.receiveShadow = true;
            digitalScreen.add(frame);
            
            // Crear la pantalla en s√≠ (m√°s grande)
            const screenGeometry = new THREE.PlaneGeometry(29, 19);
            
            // Crear un canvas para la textura de la pantalla
            const canvas = document.createElement('canvas');
            canvas.width = 1400;
            canvas.height = 900;
            const context = canvas.getContext('2d');
            
            // Rellenar el fondo
            context.fillStyle = 'rgba(0, 0, 0, 0.8)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // A√±adir un borde brillante
            context.strokeStyle = 'rgba(255, 127, 80, 0.8)';
            context.lineWidth = 10;
            context.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);
            
            // A√±adir un gradiente de fondo
            const gradient = context.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, 'rgba(255, 79, 87, 0.2)');
            gradient.addColorStop(0.5, 'rgba(255, 127, 80, 0.1)');
            gradient.addColorStop(1, 'rgba(255, 204, 0, 0.2)');
            context.fillStyle = gradient;
            context.fillRect(10, 10, canvas.width - 20, canvas.height - 20);
            
            // Configurar el estilo del texto
            context.font = 'bold 36px Arial';
            context.textAlign = 'center';
            context.fillStyle = 'white';
            context.shadowColor = 'rgba(255, 127, 80, 0.8)';
            context.shadowBlur = 15;
            
            // Escribir el texto del mensaje
            const text = [
                "Mi amor,",
                "",
                "Amor, ya vamos m√°s de dos meses, y cada d√≠a que pasa me doy cuenta ",
                "de algo: quiero que est√©s en mi vida, no solo ahorita, sino siempre.",
                "No me importa la distancia, no me importa lo que venga, yo estoy aqu√≠, ",
                "contigo, y siempre vas a estar en mis planes. Porque t√∫ no eres un  ",
                "agregado, t√∫ eres el centro de todo.",
                "",
                "Estoy terminando mi carrera, y aunque estos meses hayamos tenido peque√±os ",
                "problemas, siempre lo hemos solucionado, lo que m√°s me motiva es pensar en ",
                "el momento en que ya podamos estar juntos, sin estar contando los d√≠as ni las horas.",
                "Cada vez que despierto y veo tu mensaje, siento que el d√≠a va a ser mejor.",
                "Cada vez que me dices que me quieres, siento que el mundo es un lugar mejor.",
                "Cada viaje que hago para verte, yo se que no son muchos jeje, siempre voy",
                "emocionado, se que aprendere algo nuevo sobre el amor contigo.",
                "",
                "Me gusta como me tratas, como me miras, como te preocupas por mi,",
                "podria tener el plan mas aburrido del mundo, pero si estoy contigo,",
                "siento que estoy en el mejor lugar del mundo.",
                "Eres mi chikistrikis, mi amorcito, mi ni√±a pechocha, mi enojoncita, jeje bromita",
                "no te enojas tu jeje, te quiero mucho, los dias pasan volando, creo que",
                "el Diosito est√° yendo a nuestro favor, hay muchas cosas que quiero hacer",
                "juntos, la paciencia no es mi mejor virtud, y por ti espero lo que sea necesario.",
                "",
                "No olvides que est√°s en mi corazoncito, se que me faltan detalles contigo, ",
                "de momento no tengo mucho dinero, y mediante esta detalle digital intangible",
                "te estoy expresando lo mis mas sinceros sentimeintos, espero te guste.",
                "De tu cholashooooo.",
                "",
            ];
            
            // Crear una textura animada para el texto (solo crearemos la primera parte)
            window.updateScreenText = function(offset = 0) {
                // Limpiar el canvas
                context.fillStyle = 'rgba(0, 0, 0, 0.8)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // A√±adir el borde
                context.strokeStyle = 'rgba(255, 127, 80, 0.8)';
                context.lineWidth = 10;
                context.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);
                
                // A√±adir el gradiente
                context.fillStyle = gradient;
                context.fillRect(10, 10, canvas.width - 20, canvas.height - 20);
                
                // Configurar el estilo del texto
                context.font = 'bold 32px Arial';
                context.textAlign = 'center';
                context.fillStyle = 'white';
                context.shadowColor = 'rgba(255, 127, 80, 0.8)';
                context.shadowBlur = 15;
                
                // Dibujar las l√≠neas visibles actualmente
                const visibleLines = 14; // N√∫mero de l√≠neas visibles a la vez
                const startLine = Math.floor(offset);
                
                for (let i = 0; i < visibleLines && i + startLine < text.length; i++) {
                    context.fillText(
                        text[i + startLine], 
                        canvas.width / 2, 
                        100 + i * 50
                    );
                }
                
                // A√±adir indicador de desplazamiento y controles
                context.fillStyle = 'rgba(255, 255, 255, 0.9)';
                context.font = 'bold 24px Arial';
                context.fillText('‚Üë‚Üì Desplazar ‚Ä¢ ‚ù§Ô∏è Tu Cholasho Diego', canvas.width / 2, canvas.height - 40);
                
                // A√±adir indicador de m√∫sica
                if (isMusicPlaying) {
                    context.fillStyle = '#ff4757';
                    context.font = 'bold 28px Arial';
                    context.fillText('‚ô´ M√∫sica: Daft Punk - Touch ‚ô´', canvas.width / 2, 50);
                }
                
                // Actualizar la textura
                screenTexture.needsUpdate = true;
            };
            
            // Crear la textura a partir del canvas
            const screenTexture = new THREE.CanvasTexture(canvas);
            
            const screenMaterial = new THREE.MeshBasicMaterial({
                map: screenTexture,
                side: THREE.FrontSide
            });
            
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.z = 0.26;
            digitalScreen.add(screen);
            
            // A√±adir soporte para la pantalla (m√°s grande y adaptado para estar en el suelo)
            const standGeometry = new THREE.BoxGeometry(3, 0.5, 3);
            const standMaterial = new THREE.MeshStandardMaterial({
                color: 0xff4757,
                roughness: 0.3,
                metalness: 0.7
            });
            
            const stand = new THREE.Mesh(standGeometry, standMaterial);
            stand.position.y = -10.25;
            stand.position.z = 0;
            digitalScreen.add(stand);
            
            // Posicionar y orientar toda la pantalla - ahora est√° en el suelo
            digitalScreen.position.set(0, 10, -20); // Posici√≥n central, en el suelo, algo alejada
            digitalScreen.rotation.x = Math.PI * 0.1; // Ligera inclinaci√≥n hacia arriba para mejor visibilidad
            digitalScreen.visible = false;
            
            scene.add(digitalScreen);
            
            // Inicializar el texto
            window.updateScreenText(0);
            
            // Variables para el scroll del texto
            window.screenTextOffset = 0;
            
            // Llamar a la actualizaci√≥n peri√≥dicamente para animar
            setInterval(() => {
                if (digitalScreen.visible) {
                    window.updateScreenText(window.screenTextOffset);
                }
            }, 100);
        }
        
        function toggleScreen() {
            isScreenVisible = !isScreenVisible;
            digitalScreen.visible = isScreenVisible;
            
            // Animaci√≥n de aparici√≥n/desaparici√≥n con TWEEN
            if (isScreenVisible) {
                digitalScreen.scale.set(0.1, 0.1, 0.1);
                new TWEEN.Tween(digitalScreen.scale)
                    .to({ x: 0.5, y: 0.5, z: 0.5 }, 1000)
                    .easing(TWEEN.Easing.Elastic.Out)
                    .start();
                
                new TWEEN.Tween(digitalScreen.rotation)
                    .to({ z: Math.PI * 2 }, 1000)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                
                document.getElementById('toggleScreen').querySelector('.btn-text').textContent = 'Ocultar Mensaje';
            } else {
                new TWEEN.Tween(digitalScreen.scale)
                    .to({ x: 0.1, y: 0.1, z: 0.1 }, 500)
                    .easing(TWEEN.Easing.Back.In)
                    .onComplete(() => {
                        digitalScreen.visible = false;
                        digitalScreen.scale.set(0.5, 0.5, 0.5);
                        digitalScreen.rotation.z = 0;
                    })
                    .start();
                
                document.getElementById('toggleScreen').querySelector('.btn-text').textContent = 'Mostrar Mensaje';
            }
        }
        
        function toggleMusic() {
            const audioPlayer = document.getElementById('audioPlayer');
            const musicBtn = document.getElementById('toggleMusic');
            
            if (isMusicPlaying) {
                // Pausar m√∫sica con fade out
                let vol = audioPlayer.volume;
                const fadeOut = setInterval(() => {
                    if (vol > 0.02) {
                        vol -= 0.02;
                        audioPlayer.volume = vol;
                    } else {
                        clearInterval(fadeOut);
                        audioPlayer.pause();
                        isMusicPlaying = false;
                        musicBtn.classList.remove('music-active');
                        musicBtn.querySelector('.btn-text').textContent = 'Reproducir';
                        musicBtn.querySelector('.btn-icon').textContent = 'üéµ';
                    }
                }, 50);
            } else {
                // Reproducir m√∫sica con fade in
                audioPlayer.play();
                audioPlayer.volume = 0;
                isMusicPlaying = true;
                musicBtn.classList.add('music-active');
                musicBtn.querySelector('.btn-text').textContent = 'Pausar';
                musicBtn.querySelector('.btn-icon').textContent = '‚ô´';
                
                let vol = 0;
                const fadeIn = setInterval(() => {
                    if (vol < 0.5) {
                        vol += 0.01;
                        audioPlayer.volume = vol;
                    } else {
                        clearInterval(fadeIn);
                    }
                }, 50);
            }
        }
        
        function createCat() {
            cat = new THREE.Group();
            
            // Cuerpo
            const bodyGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            bodyGeometry.scale(1.5, 1, 1.2);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x151515,
                roughness: 0.8
            });
            
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.position.y = 1.5;
            cat.add(body);
            
            // Cabeza
            const headGeometry = new THREE.SphereGeometry(1, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0x151515,
                roughness: 0.7
            });
            
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.castShadow = true;
            head.position.set(1.5, 2.5, 0);
            cat.add(head);
            
            // Orejas
            const earGeometry = new THREE.ConeGeometry(0.4, 0.8, 4);
            const earMaterial = new THREE.MeshStandardMaterial({
                color: 0x0d0d0d,
                roughness: 0.9
            });
            
            const earLeft = new THREE.Mesh(earGeometry, earMaterial);
            earLeft.castShadow = true;
            earLeft.position.set(1.7, 3.3, -0.5);
            earLeft.rotation.z = -Math.PI / 4;
            cat.add(earLeft);
            
            const earRight = new THREE.Mesh(earGeometry, earMaterial);
            earRight.castShadow = true;
            earRight.position.set(1.7, 3.3, 0.5);
            earRight.rotation.z = -Math.PI / 4;
            cat.add(earRight);
            
            // Ojos
            const eyeGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const eyeMaterial = new THREE.MeshStandardMaterial({
                color: 0xd4af37,
                roughness: 0.3,
                metalness: 0.4,
                emissive: 0x554411,
                emissiveIntensity: 0.5
            });
            
            const eyeLeft = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eyeLeft.position.set(2.1, 2.7, -0.4);
            cat.add(eyeLeft);
            
            const eyeRight = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eyeRight.position.set(2.1, 2.7, 0.4);
            cat.add(eyeRight);
            
            // Cola
            const tailCurve = new THREE.CubicBezierCurve3(
                new THREE.Vector3(-1.5, 1.5, 0),
                new THREE.Vector3(-3, 2, 0),
                new THREE.Vector3(-3.5, 3, 0),
                new THREE.Vector3(-2.5, 4, 0)
            );
            
            const tailGeometry = new THREE.TubeGeometry(tailCurve, 20, 0.2, 8, false);
            const tailMaterial = new THREE.MeshStandardMaterial({
                color: 0x0d0d0d,
                roughness: 0.8
            });
            
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.castShadow = true;
            cat.add(tail);
            
            // Posicionar el gato
            cat.position.set(0, 0, 10);
            cat.scale.set(0.8, 0.8, 0.8);
            scene.add(cat);
        }
        
        // Crear part√≠culas (corazones que flotan)
        function createParticles() {
            // Crear geometr√≠a de coraz√≥n
            const heartShape = new THREE.Shape();
            const x = 0, y = 0;
            
            heartShape.moveTo(x, y + 1);
            heartShape.bezierCurveTo(x + 1, y + 1, x + 1.5, y, x, y - 1);
            heartShape.bezierCurveTo(x - 1.5, y, x - 1, y + 1, x, y + 1);
            
            const heartGeometry = new THREE.ExtrudeGeometry(heartShape, {
                depth: 0.2,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.2,
                bevelSegments: 3
            });
            
            // Crear varios corazones flotantes
            for (let i = 0; i < 30; i++) {
                const heartMaterial = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(
                        0.9 + Math.random() * 0.1,
                        0.1 + Math.random() * 0.1,
                        0.1 + Math.random() * 0.1
                    ),
                    roughness: 0.3,
                    metalness: 0.2,
                    transparent: true,
                    opacity: 0.7 + Math.random() * 0.3,
                    side: THREE.DoubleSide
                });
                
                const heart = new THREE.Mesh(heartGeometry, heartMaterial);
                heart.scale.set(0.1, 0.1, 0.1);
                
                heart.position.set(
                    THREE.MathUtils.randFloatSpread(60),
                    2 + Math.random() * 10,
                    THREE.MathUtils.randFloatSpread(60)
                );
                
                heart.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                
                // Propiedades para animaci√≥n
                heart.userData = {
                    rotSpeed: (Math.random() - 0.5) * 0.02,
                    floatSpeed: 0.2 + Math.random() * 0.3,
                    floatHeight: 1 + Math.random() * 2,
                    originalY: heart.position.y,
                    floatOffset: Math.random() * Math.PI * 2
                };
                
                hearts.push(heart);
                scene.add(heart);
            }
        }
        
        // Configurar controles para explorar la escena
        function setupControls() {
            // Variables para el control de la c√°mara con el rat√≥n
            let isMouseDown = false;
            let mouseX = 0;
            let mouseY = 0;
            let targetRotationX = 0;
            let targetRotationY = 0;
            let currentRotationX = 0;
            let currentRotationY = 0;
            
            // Variables para el movimiento con teclado
            const keys = {
                w: false,
                a: false,
                s: false,
                d: false
            };
            
            // Eventos de rat√≥n
            document.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            document.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            document.addEventListener('mousemove', (event) => {
                if (isMouseDown) {
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                    
                    targetRotationX -= deltaX * 0.01;
                    targetRotationY = Math.max(-Math.PI/4, Math.min(Math.PI/4, targetRotationY - deltaY * 0.01));
                }
            });
            
            // Eventos de teclado
            document.addEventListener('keydown', (event) => {
                switch (event.key.toLowerCase()) {
                    case 'w': keys.w = true; break;
                    case 'a': keys.a = true; break;
                    case 's': keys.s = true; break;
                    case 'd': keys.d = true; break;
                    case 'e': 
                        document.getElementById('centeredCard').style.display = 
                            document.getElementById('centeredCard').style.display === 'flex' ? 'none' : 'flex';
                        break;
                }
            });
            
            document.addEventListener('keyup', (event) => {
                switch (event.key.toLowerCase()) {
                    case 'w': keys.w = false; break;
                    case 'a': keys.a = false; break;
                    case 's': keys.s = false; break;
                    case 'd': keys.d = false; break;
                }
            });
            
            // Funci√≥n para actualizar la posici√≥n de la c√°mara
            window.updateCamera = function(delta) {
                // Suavizar la rotaci√≥n
                currentRotationX += (targetRotationX - currentRotationX) * 0.1;
                currentRotationY += (targetRotationY - currentRotationY) * 0.1;
                
                // Aplicar rotaci√≥n
                camera.rotation.order = 'YXZ';
                camera.rotation.y = currentRotationX;
                camera.rotation.x = currentRotationY;
                
                // Movimiento basado en teclado
                const speed = 10 * delta;
                const direction = new THREE.Vector3();
                
                // Obtener la direcci√≥n frontal (excluir el componente Y para mantener el movimiento en el plano horizontal)
                const frontVector = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                frontVector.y = 0;
                frontVector.normalize();
                
                // Obtener la direcci√≥n lateral
                const rightVector = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                rightVector.y = 0;
                rightVector.normalize();
                
                // Aplicar las direcciones seg√∫n las teclas presionadas
                if (keys.w) direction.add(frontVector);
                if (keys.s) direction.sub(frontVector);
                if (keys.a) direction.sub(rightVector);
                if (keys.d) direction.add(rightVector);
                
                // Normalizar la direcci√≥n si hay movimiento
                if (direction.length() > 0) {
                    direction.normalize();
                    camera.position.addScaledVector(direction, speed);
                    
                    // Limitar el movimiento dentro de un √°rea
                    camera.position.x = Math.max(-50, Math.min(50, camera.position.x));
                    camera.position.z = Math.max(-50, Math.min(50, camera.position.z));
                    
                    // Mantener la altura
                    camera.position.y = 5;
                }
            };
        }
        
        // Redimensionar la ventana
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Animaci√≥n de la escena
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            // Actualizar animaciones con TWEEN
            TWEEN.update();
            
            // Actualizar la c√°mara
            window.updateCamera(delta);
            
            // Animaci√≥n del sol
            if (sun) {
                sun.children[0].scale.x = 1 + Math.sin(clock.getElapsedTime() * 0.5) * 0.1;
                sun.children[0].scale.y = 1 + Math.sin(clock.getElapsedTime() * 0.5) * 0.1;
                sun.children[0].scale.z = 1 + Math.sin(clock.getElapsedTime() * 0.5) * 0.1;
            }
            
            // Animaci√≥n de las palmeras
            if (palmGroup) {
                palmGroup.children.forEach((palm, i) => {
                    palm.children.forEach((part, j) => {
                        if (j > 0) { // Solo las hojas
                            part.rotation.z += Math.sin(clock.getElapsedTime() * 0.5 + i * 0.1) * 0.002;
                            part.rotation.y += Math.sin(clock.getElapsedTime() * 0.3 + i * 0.1) * 0.001;
                        }
                    });
                });
            }
            
            // Animaci√≥n de las flores
            if (flowerField) {
                flowerField.children.forEach((flower, i) => {
                    flower.rotation.y = Math.sin(clock.getElapsedTime() * 0.3 + i * 0.1) * 0.05;
                    flower.position.y = Math.sin(clock.getElapsedTime() * 0.5 + i * 0.3) * 0.1;
                });
            }
            
            // Animaci√≥n del gato
            if (cat) {
                cat.children[cat.children.length - 1].rotation.z = Math.sin(clock.getElapsedTime() * 2) * 0.2; // Cola
                cat.rotation.y = Math.sin(clock.getElapsedTime() * 0.5) * 0.1; // Cuerpo girando suavemente
            }
            
            // Animaci√≥n de los corazones
            hearts.forEach(heart => {
                const userData = heart.userData;
                
                // Rotaci√≥n
                heart.rotation.x += userData.rotSpeed;
                heart.rotation.y += userData.rotSpeed * 1.5;
                
                // Movimiento flotante
                heart.position.y = userData.originalY + 
                    Math.sin(clock.getElapsedTime() * userData.floatSpeed + userData.floatOffset) * 
                    userData.floatHeight;
            });
            
            // Animaci√≥n de la pantalla digital
            if (digitalScreen && digitalScreen.visible) {
                // Hacer que la pantalla tenga un suave efecto de resplandor
                if (digitalScreen.children[0].material) {
                    const pulseFactor = (Math.sin(clock.getElapsedTime() * 2) + 1) * 0.5;
                    digitalScreen.children[0].material.emissiveIntensity = 0.1 + pulseFactor * 0.3;
                }
            }
            
            renderer.render(scene, camera);
        }
        
        // Cerrar el modal inicial
        function closeModal() {
            document.getElementById("myModal").style.display = "none";
            setupAudio();
            document.getElementById('audioPlayer').play();
        }
        
        // Ya no necesitamos esta funci√≥n pues ahora usamos la pantalla 3D
        function closeCard() {
            document.getElementById("centeredCard").style.display = "none";
        }
        
        // Teclas para controlar la escena
        document.addEventListener('keydown', function(event) {
            // 'P' para mostrar/ocultar la pantalla digital
            if (event.key.toLowerCase() === 'p') {
                toggleScreen();
            }
            
            // 'M' para controlar la m√∫sica
            if (event.key.toLowerCase() === 'm') {
                toggleMusic();
            }
            
            // Atajos adicionales
            if (event.key === 'Escape') {
                // Cerrar cualquier modal o pantalla
                if (document.getElementById("myModal").style.display === "block") {
                    closeModal();
                } else if (isScreenVisible) {
                    toggleScreen();
                }
            }
        });
        
        // Iniciar todo cuando se carga la p√°gina
        window.onload = function() {
            init();
            
            // Mostrar mensaje principal despu√©s de cargar
            setTimeout(() => {
                document.getElementById("myModal").style.display = "block";
            }, 2500);
            
            // Actualizar el texto de ayuda
            document.querySelector('.controls-hint').innerHTML = 
                'WASD: Moverte | Rat√≥n: Mirar | P: Mensaje | M: M√∫sica | ‚Üë‚Üì: Desplazar texto';
                
            // Auto-mostrar la pantalla digital despu√©s de cerrar el modal
            setTimeout(() => {
                if (!isScreenVisible) {
                    toggleScreen();
                }
            }, 5000);
        };


        // Detectar si es un dispositivo m√≥vil
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // Si es un dispositivo m√≥vil, a√±adir el texto de ayuda para m√≥viles
    if (isMobile) {
        const mobileHint = document.createElement('div');
        mobileHint.className = 'mobile-controls-hint';
        mobileHint.innerHTML = 'Desliza para mirar alrededor y usa el joystick para moverte';
        document.body.appendChild(mobileHint);
        
        // Ocultar el hint despu√©s de 5 segundos
        setTimeout(() => {
            mobileHint.style.opacity = '0';
            setTimeout(() => {
                mobileHint.style.display = 'none';
            }, 1000);
        }, 5000);
    }
    
    // Configuraci√≥n del joystick virtual
    function setupMobileControls() {
        // Referencias a elementos del DOM
        const joystickBase = document.getElementById('joystick-base');
        const joystickThumb = document.getElementById('joystick-thumb');
        const mobileMessageBtn = document.getElementById('mobile-message');
        const mobileMusicBtn = document.getElementById('mobile-music');
        
        // Variables para el joystick
        let joystickActive = false;
        let joystickOrigin = { x: 0, y: 0 };
        let currentPosition = { x: 0, y: 0 };
        let joystickVector = { x: 0, y: 0 };
        
        // Variables para el control de vista
        let touchStartX = 0;
        let touchStartY = 0;
        let touchActive = false;
        
        // Configurar el joystick
        function initJoystick() {
            const baseRect = joystickBase.getBoundingClientRect();
            joystickOrigin = {
                x: baseRect.left + baseRect.width / 2,
                y: baseRect.top + baseRect.height / 2
            };
            joystickThumb.style.transform = 'translate(0px, 0px)';
        }
        
        // Actualizar visualmente el joystick
        function updateJoystickThumb() {
            // Calcular el vector del joystick
            const dx = currentPosition.x - joystickOrigin.x;
            const dy = currentPosition.y - joystickOrigin.y;
            
            // Limitar el movimiento dentro del radio del joystick
            const maxDistance = joystickBase.offsetWidth / 2;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > maxDistance) {
                const angle = Math.atan2(dy, dx);
                const limitedX = Math.cos(angle) * maxDistance;
                const limitedY = Math.sin(angle) * maxDistance;
                
                joystickThumb.style.transform = `translate(${limitedX}px, ${limitedY}px)`;
                
                // Calcular vector normalizado para el movimiento (entre -1 y 1)
                joystickVector = {
                    x: limitedX / maxDistance,
                    y: limitedY / maxDistance
                };
            } else {
                joystickThumb.style.transform = `translate(${dx}px, ${dy}px)`;
                
                // Calcular vector normalizado para el movimiento (entre -1 y 1)
                joystickVector = {
                    x: dx / maxDistance,
                    y: dy / maxDistance
                };
            }
        }
        
        // Registrar cuando el joystick se activa
        joystickBase.addEventListener('touchstart', (e) => {
            e.preventDefault();
            joystickActive = true;
            const touch = e.touches[0];
            currentPosition = { x: touch.clientX, y: touch.clientY };
            updateJoystickThumb();
        });
        
        // Registrar cuando el joystick se mueve
        document.addEventListener('touchmove', (e) => {
            // Solo procesar si hay toques
            if (e.touches.length === 0) return;
            
            // Encontrar qu√© dedo est√° controlando el joystick y cu√°l est√° controlando la vista
            for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                const touchX = touch.clientX;
                const touchY = touch.clientY;
                
                // Comprobar si este toque est√° en el joystick
                const joystickRect = joystickBase.getBoundingClientRect();
                const inJoystick = (
                    touchX >= joystickRect.left - 50 &&
                    touchX <= joystickRect.right + 50 &&
                    touchY >= joystickRect.top - 50 &&
                    touchY <= joystickRect.bottom + 50
                );
                
                if (inJoystick && joystickActive) {
                    // Este toque es para el joystick
                    currentPosition = { x: touchX, y: touchY };
                    updateJoystickThumb();
                } else if (!inJoystick) {
                    // Este toque es para la c√°mara
                    if (!touchActive) {
                        touchActive = true;
                        touchStartX = touchX;
                        touchStartY = touchY;
                    } else {
                        // Calcular deltas para la rotaci√≥n de la c√°mara
                        const deltaX = touchX - touchStartX;
                        const deltaY = touchY - touchStartY;
                        
                        // Actualizar la rotaci√≥n objetivo de la c√°mara
                        targetRotationX -= deltaX * 0.01;
                        targetRotationY = Math.max(-Math.PI/4, Math.min(Math.PI/4, targetRotationY - deltaY * 0.01));
                        
                        // Actualizar posici√≥n inicial para el pr√≥ximo movimiento
                        touchStartX = touchX;
                        touchStartY = touchY;
                    }
                }
            }
        });
        
        // Registrar cuando el joystick se suelta
        document.addEventListener('touchend', (e) => {
            // Comprobar si todos los dedos se han levantado
            if (e.touches.length === 0) {
                // Resetear el joystick
                joystickActive = false;
                joystickThumb.style.transform = 'translate(0px, 0px)';
                joystickVector = { x: 0, y: 0 };
                
                // Resetear el control de la c√°mara
                touchActive = false;
            } else {
                // Comprobar si el dedo del joystick se ha levantado
                let joystickTouchActive = false;
                for (let i = 0; i < e.touches.length; i++) {
                    const touch = e.touches[i];
                    const joystickRect = joystickBase.getBoundingClientRect();
                    const inJoystick = (
                        touch.clientX >= joystickRect.left - 50 &&
                        touch.clientX <= joystickRect.right + 50 &&
                        touch.clientY >= joystickRect.top - 50 &&
                        touch.clientY <= joystickRect.bottom + 50
                    );
                    
                    if (inJoystick) {
                        joystickTouchActive = true;
                    }
                }
                
                if (!joystickTouchActive) {
                    joystickActive = false;
                    joystickThumb.style.transform = 'translate(0px, 0px)';
                    joystickVector = { x: 0, y: 0 };
                }
            }
        });
        
        // Botones para controlar el mensaje y la m√∫sica
        mobileMessageBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            toggleScreen();
        });
        
        mobileMusicBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            toggleMusic();
        });
        
        // Modificar la funci√≥n updateCamera para usar el joystick en m√≥viles
        const originalUpdateCamera = window.updateCamera;
        window.updateCamera = function(delta) {
            // Llamar a la funci√≥n original para controles de teclado en PC
            originalUpdateCamera(delta);
            
            // A√±adir movimiento basado en el joystick para m√≥viles
            if (isMobile && (joystickVector.x !== 0 || joystickVector.y !== 0)) {
                const speed = 10 * delta;
                const direction = new THREE.Vector3();
                
                // Obtener la direcci√≥n frontal (excluir el componente Y para mantener el movimiento en el plano horizontal)
                const frontVector = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                frontVector.y = 0;
                frontVector.normalize();
                
                // Obtener la direcci√≥n lateral
                const rightVector = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                rightVector.y = 0;
                rightVector.normalize();
                
                // Aplicar las direcciones seg√∫n el joystick
                direction.add(frontVector.clone().multiplyScalar(-joystickVector.y));
                direction.add(rightVector.clone().multiplyScalar(joystickVector.x));
                
                // Normalizar la direcci√≥n si hay movimiento
                if (direction.length() > 0) {
                    direction.normalize();
                    camera.position.addScaledVector(direction, speed);
                    
                    // Limitar el movimiento dentro de un √°rea
                    camera.position.x = Math.max(-50, Math.min(50, camera.position.x));
                    camera.position.z = Math.max(-50, Math.min(50, camera.position.z));
                    
                    // Mantener la altura
                    camera.position.y = 5;
                }
            }
        };
        
        // Inicializar el joystick
        window.addEventListener('resize', initJoystick);
        initJoystick();
    }
    
    // Inicializar controles m√≥viles cuando se carga la p√°gina
    document.addEventListener('DOMContentLoaded', () => {
        if (isMobile) {
            setupMobileControls();
        }
    });

    </script>
    <!-- A√±ade este c√≥digo justo antes del cierre del body (antes de </body>) -->

<!-- Controles m√≥viles -->
<div id="mobile-controls" class="mobile-controls">
    <div class="joystick-container">
        <div id="joystick-base" class="joystick-base">
            <div id="joystick-thumb" class="joystick-thumb"></div>
        </div>
    </div>
    <div class="mobile-buttons">
        <button id="mobile-message" class="mobile-btn">
            <span class="mobile-btn-icon">üíå</span>
        </button>
        <button id="mobile-music" class="mobile-btn">
            <span class="mobile-btn-icon">üéµ</span>
        </button>
    </div>
</div>
</body>
</html>